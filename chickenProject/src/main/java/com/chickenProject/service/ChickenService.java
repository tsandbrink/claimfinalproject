package com.chickenProject.service;

import java.time.LocalDate;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;
import java.util.List;
import com.chickenProject.repo.ChickenRepo;
import com.chickenProject.entity.Chicken;
import com.chickenProject.entity.TreeNode;
import com.chickenProject.entity.Chicken;


import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import org.springframework.stereotype.Service;


@Service
public class ChickenService {
    
    @Autowired
    private ChickenRepo chickenRepo;

    public Chicken save(Chicken chicken) {
		// Another predefined function, used to save your objects
		// Id will be autogenerated and will come back in the return after its saved

	    return chickenRepo.save(chicken);
	}
	
	public Chicken update(Chicken chicken) throws Exception {
		// Another predefined function, used to save your objects
		// Id will be autogenerated and will come back in the return after its saved

        if(chicken.getId() != null) {
	        return chickenRepo.save(chicken);
        }

        throw new Exception("Object does not exist! id not present");
	}
    
    public Chicken findById(Integer chickenId) throws Error {
        
    	// Find by is another predefined repo function, you can always find by the primary key
    	// when you use findById, its good practice to use the isPresent in an if check first
    	// It will tell you if a object was actually found, with true or false values, true if found, false is not
    	// It will always return an Optional Object, the chicken will be there if found, null if not
    	// If found, give the object back with a .get() to grab it off the Optional object
    	
        if(chickenRepo.findById(chickenId).isPresent()) {
            return chickenRepo.findById(chickenId).get();
        }
        
        // if chicken is not present, throw error so front end can handle it
        throw new Error("No chicken id present, Chicken not found, send an id billy, dumbass");
        
    }

    public Chicken findByName(String chickenName) throws Error {
        
    	// Find by is another predefined repo function, you can always find by the primary key
    	// when you use findById, its good practice to use the isPresent in an if check first
    	// It will tell you if a object was actually found, with true or false values, true if found, false is not
    	// It will always return an Optional Object, the chicken will be there if found, null if not
    	// If found, give the object back with a .get() to grab it off the Optional object
    	
        if (chickenRepo.findByName(chickenName)!=null){
            return chickenRepo.findByName(chickenName);
        } else {
            throw new Error("No chicken by thah name present");
        }
            
        
        
    
        
    }

	public List<Chicken> findAll() {
		return chickenRepo.findAll();
	}

    public void deleteById(Integer id) {
	    chickenRepo.deleteById(id);
	}

    public Long calculateAgeInWeeks(Chicken chicken){
        LocalDate dateOfBirth = chicken.getBirthdate();
        Long daysBetween = ChronoUnit.DAYS.between(dateOfBirth, LocalDate.now());
        return (daysBetween/7);
    }

    public List<Chicken> findAncestors(Chicken chicken){
        List<Chicken> ancestors = new ArrayList<Chicken>();
        Integer currentGeneration = 1;
        Integer firstPosition = 1;
        TreeNode firsTreeNode = new TreeNode(currentGeneration, firstPosition);
        ancestors.add(chicken);
        chicken.getTreeNodes().add(firsTreeNode);
        ancestors = findAncestors2(chicken, ancestors, currentGeneration);
        int maxRow = 0;
        for (Chicken c : ancestors) {
            for (TreeNode t : c.getTreeNodes()) {
                if (t.getGeneration() > maxRow){
                    maxRow = t.getGeneration();
                }
            }
        }
        
        for (Chicken c : ancestors) {
            for (TreeNode t : c.getTreeNodes()) {
                if (t.getGeneration() != maxRow && t.getGeneration()!=1){
                    int multiplier = 0;
                      
                    for (int i = 0; i < (maxRow - t.getGeneration()); i++){
                        multiplier += Math.pow(2, i);
                        
                    }
                    
                    int currentPosition = t.getPosition();
                    int newPosition =  t.getPosition();
                    for (int i = 1; i < currentPosition; i++){
                        
                        newPosition += multiplier;
                        
                    }
                    t.setPosition(newPosition);
                }     
            }
        }
        return ancestors;
    }

    public List<Chicken> findAncestors2(Chicken chicken, List<Chicken> ancestors, Integer currentGeneration){
        
        if ((chicken.getFatherId() == null || chicken.getFatherId() == 0) && (chicken.getMotherId() == null || chicken.getMotherId() == 0)){
            
            return ancestors;
        } else {
            currentGeneration += 1;
            Integer currentMotherPosition = 2 * chicken.getTreeNodes().get(chicken.getTreeNodes().size()-1).getPosition();
            Integer currentFatherPosition = 2 * chicken.getTreeNodes().get(chicken.getTreeNodes().size()-1).getPosition() -1;
            TreeNode motherNode = new TreeNode(currentGeneration, currentMotherPosition);
            TreeNode fatherNode = new TreeNode(currentGeneration, currentFatherPosition);
            if (chicken.getMotherId() != null && chicken.getMotherId() != 0){
                Chicken mother = findById(chicken.getMotherId());
                mother.getTreeNodes().add(motherNode);
                if(!ancestors.contains(mother)){
                    ancestors.add(mother);
                }
                findAncestors2(mother, ancestors, currentGeneration);
            }
            if (chicken.getFatherId() != null && chicken.getFatherId() != 0){
                Chicken father = findById(chicken.getFatherId());
                father.getTreeNodes().add(fatherNode);
                if(!ancestors.contains(father)){
                ancestors.add(father);
                findAncestors2(father, ancestors, currentGeneration);
                }
            }
            
        }
        
        return ancestors;
    }

    public Double findAverageEggsPerWeek (List<Chicken> chickens) throws Exception{
        List<Double> averageEggs = new ArrayList<Double>();
        for (Chicken c : chickens) {
            if (calculateAgeInWeeks(c) > 0){
                Double eggsPerWeek = c.getEggsLaid()/(double)calculateAgeInWeeks(c);
                averageEggs.add(eggsPerWeek);
            } else {
                averageEggs.add((double)c.getEggsLaid());
            }
            
        }
        Double sumOfAverages = 0.0;
        for (Double d : averageEggs) {
            sumOfAverages += d;
        }
        if (averageEggs.size() > 0){
            return sumOfAverages/averageEggs.size();
        } else {
            throw new Error("No Chickens in List - Can't Divide By 0");
        }
        
    }

    public List<Chicken> findByStateAndBreed(String state, String breed) throws Error{
        if (chickenRepo.findByStateAndBreed(state, breed).size() > 0){
            return chickenRepo.findByStateAndBreed(state, breed);
        }
        else {
            throw new Error("No chickens found");
        }
    }

    public List<Chicken> findByZipCodeAndBreed(String zipCode, String breed) throws Error{
        if (chickenRepo.findByZipCodeAndBreed(zipCode, breed).size() > 0){
            return chickenRepo.findByZipCodeAndBreed(zipCode, breed);
        }
        else {
            throw new Error("No chickens found");
        }
    }

    public List<Chicken> findByBreed(String breed) throws Error{
        if (chickenRepo.findByBreed(breed).size() > 0){
            return chickenRepo.findByBreed(breed);
        }
        else {
            throw new Error("No chickens found");
        }
    }
    
    // public Chicken addEgg(Chicken chicken, Integer eggsToAdd){
    //     chicken.setEggsLaid(chicken.getEggsLaid() + eggsToAdd);
    //     return update(chicken);
    // }

    //method to get feed needs of a chick
    // getFeedNeeds(chicken){
    // double ageInWeeks = current date - chicken.get date of birth / 7
    // if age > 21 age = 21
    // if age is < 21 and odd - 1
    // Double feed = chickenFeedNeed.get(age)
    // Return feed
    //}
    // 

    /* 
    public List<Chicken> getDescendants(Chicken chicken){
        List<Chicken> descendants = new ArrayList<Chicken>();
        descendants = findChildren(chicken, descendants);
        return descendants;
    }

    //Recursive Method where Takes in a chicken and a list and adds the children to the list then adds the children of the children to the list and then children of children of children and so on...

    public List<Chicken> findChildren(Chicken chicken, List<Chicken> descendants){
        for (Chicken c:chicken.getChildren()) {
            descendants.add(c);
            if(c.getChildren().size() == 0){
                return descendants;
            } else {
                findChildren(c, descendants);
            }
        }
        return descendants;
    } */
}
